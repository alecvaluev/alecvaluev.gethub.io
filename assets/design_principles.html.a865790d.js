import{_ as e,o as i,c as t,f as n}from"./app.b4bb9481.js";const a={},o=n('<h1 id="oop-design-principles" tabindex="-1"><a class="header-anchor" href="#oop-design-principles" aria-hidden="true">#</a> OOP Design Principles</h1><p>Intro to the <strong>SOLID</strong> principles -</p><blockquote><p>Single responsibility</p><p>Open-closed</p><p>Liskov substitution,</p><p>Interface segregation</p><p>and Dependency inversion</p></blockquote><p>...and other important principles for designing</p><h2 id="dry-don-t-repeat-yourself" tabindex="-1"><a class="header-anchor" href="#dry-don-t-repeat-yourself" aria-hidden="true">#</a> DRY (Don\u2019t repeat yourself)</h2><div class="custom-container tip"><p class="custom-container-title">principle</p><p>don\u2019t write duplicate code</p></div><p>instead use Abstraction to abstract common things in one place.</p><p>If you have a <strong>block of code</strong> in more than two places consider making it a separate method, or if you use <strong>a hard-coded value</strong> more than one time make them public final constant.</p><p>The benefit of this - <code>maintenance</code>.</p><h2 id="encapsulate-what-changes" tabindex="-1"><a class="header-anchor" href="#encapsulate-what-changes" aria-hidden="true">#</a> Encapsulate What Changes</h2><div class="custom-container tip"><p class="custom-container-title">principle</p><p>hides implementation detail, helps in maintenance</p></div><div class="custom-container tip"><p class="custom-container-title">Benefit</p><p>easy to test and maintain proper encapsulated code.</p></div><h2 id="single-responsibility-principle-srp" tabindex="-1"><a class="header-anchor" href="#single-responsibility-principle-srp" aria-hidden="true">#</a> Single Responsibility Principle (SRP)</h2><div class="custom-container tip"><p class="custom-container-title">principle</p><p>one class should do one thing and do it well</p></div><div class="custom-container tip"><p class="custom-container-title">Benefit</p><p>reduces coupling between the individual component of the software and Code</p></div><h2 id="open-closed-design-principle-ocp" tabindex="-1"><a class="header-anchor" href="#open-closed-design-principle-ocp" aria-hidden="true">#</a> Open Closed design principle (OCP)</h2><div class="custom-container tip"><p class="custom-container-title">principle</p><p>open for extension, closed for modification</p></div><p>Ideally, if you are adding new functionality only than your code should be tested</p><div class="custom-container tip"><p class="custom-container-title">Benefit</p><p>already tried and tested code is not touched which means they won\u2019t break.</p></div><h2 id="liskov-substitution-principle-lsp" tabindex="-1"><a class="header-anchor" href="#liskov-substitution-principle-lsp" aria-hidden="true">#</a> Liskov Substitution Principle (LSP)</h2><div class="custom-container tip"><p class="custom-container-title">principle</p><p>sub type must be substitutable for super type</p></div><h2 id="interface-segregation-principle-isp" tabindex="-1"><a class="header-anchor" href="#interface-segregation-principle-isp" aria-hidden="true">#</a> Interface Segregation Principle (ISP)</h2><p>avoid monolithic interface, reduce pain on client side</p><div class="custom-container tip"><p class="custom-container-title">principle</p><p>The ISP requires that clients should not be forced to depend on interfaces that they do not use.</p></div><h2 id="dependency-inversion-principle-dip" tabindex="-1"><a class="header-anchor" href="#dependency-inversion-principle-dip" aria-hidden="true">#</a> Dependency Inversion Principle (DIP)</h2><p>don&#39;t ask, let framework give to you</p><div class="custom-container tip"><p class="custom-container-title">principle</p><p>The DIP requires that high level modules should not depend on low level modules, both should depend on abstraction. Also, abstraction should not depend on details, details should depend on abstractions</p></div><h2 id="favor-composition-over-inheritance" tabindex="-1"><a class="header-anchor" href="#favor-composition-over-inheritance" aria-hidden="true">#</a> Favor Composition over Inheritance</h2><div class="custom-container tip"><p class="custom-container-title">principle</p><p>code reuse without cost of inflexibility</p></div><p>Composition allows changing the behavior of a class at run-time by setting property during run-time and by using Interfaces to compose a class we use polymorphism which provides flexibility to replace with better implementation any time.</p><h2 id="programmning-for-interface" tabindex="-1"><a class="header-anchor" href="#programmning-for-interface" aria-hidden="true">#</a> Programmning for Interface</h2><div class="custom-container tip"><p class="custom-container-title">Benefit</p><p>helps in maintenance, improves flexibility</p></div><p>A programmer should always program for the interface and not for implementation this will lead to flexible code which can work with any new implementation of the interface.</p><p>In concrete words, you should use interface type on variables, return types of a method or argument type of methods in Java like using SuperClass type to store object rather using SubClass.</p><h2 id="delegation-principle" tabindex="-1"><a class="header-anchor" href="#delegation-principle" aria-hidden="true">#</a> Delegation principle</h2><p>don&#39;t do all things by yourself, delegate it</p><p>Don\u2019t do all stuff by yourself, delegate it to the respective class. Classical example of delegation design principle is equals() and hashCode() method in Java.</p><div class="custom-container tip"><p class="custom-container-title">Benefit</p><p>no duplication of code and pretty easy to modify behavior.</p></div>',38),s=[o];function r(p,c){return i(),t("div",null,s)}const l=e(a,[["render",r],["__file","design_principles.html.vue"]]);export{l as default};

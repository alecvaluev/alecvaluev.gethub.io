import{_ as r,r as o,o as a,c as l,b as e,d as n,e as t,f as s}from"./app.df0ac280.js";const h={},u=e("h1",{id:"coding-patterns",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#coding-patterns","aria-hidden":"true"},"#"),t(" Coding Patterns")],-1),p={href:"https://hackernoon.com/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed",target:"_blank",rel:"noopener noreferrer"},d=t("14 Patters to Ace"),c=s('<ol><li>Sliding Window</li></ol><p>When to use:</p><ul><li>The problem input is a linear data structure such as a linked list, array, or string</li><li>You\u2019re asked to find the longest/shortest substring, subarray, or a desired value</li></ul><p>Problem patterns:</p><ul><li>Maximum sum subarray of size \u2018K\u2019 (easy)</li><li>Longest substring with \u2018K\u2019 distinct characters (medium)</li><li>String anagrams (hard)</li></ul><ol start="2"><li>Two Pointers or Iterators</li></ol><p>Two Pointers is a pattern where two pointers iterate through the data structure in tandem until one or both of the pointers hit a certain condition.Two Pointers is often useful when searching pairs in a sorted array or linked list</p><p>When to use:</p><ul><li>It will feature problems where you deal with sorted arrays (or Linked Lists) and need to find a set of elements that fulfill certain constraints</li><li>The set of elements in the array is a pair, a triplet, or even a subarray</li></ul><p>Problem patterns:</p><ul><li>Squaring a sorted array (easy)</li><li>Triplets that sum to zero (medium)</li><li>Comparing strings that contain backspaces (medium)</li></ul><ol start="3"><li>Fast and Slow pointers (Hare &amp; Tortoise algorithm)</li></ol><p>is a pointer algorithm that uses two pointers which move through the array (or sequence/linked list) at different speeds. This approach is quite useful when dealing with cyclic linked lists or arrays.</p><p>How do you identify when to use the Fast and Slow pattern?</p><ul><li>The problem will deal with a loop in a linked list or array</li><li>When you need to know the position of a certain element or the overall length of the linked list.</li></ul><p>When should I use it over the Two Pointer method mentioned above?</p><ul><li>There are some cases where you shouldn\u2019t use the Two Pointer approach such as in a singly linked list where you can\u2019t move in a backwards direction. An example of when to use the Fast and Slow pattern is when you\u2019re trying to determine if a linked list is a palindrome.</li></ul><p>Problem patterns:</p><ul><li>Linked List Cycle (easy)</li><li>Palindrome Linked List (medium)</li><li>Cycle in a Circular Array (hard)</li></ul><ol start="4"><li>Merge Intervals</li></ol><p>pattern is an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, you either need to find overlapping intervals or merge intervals if they overlap.</p><h3 id="the-pattern-works-like-this" tabindex="-1"><a class="header-anchor" href="#the-pattern-works-like-this" aria-hidden="true">#</a> The pattern works like this:</h3><p>Given two intervals (\u2018a\u2019 and \u2018b\u2019), there will be six different ways the two intervals can relate to each other:</p><p>recognizing these six cases will help you help you solve a wide range of problems from inserting intervals to optimizing interval merges.</p><p>When to use:</p><ul><li>If you\u2019re asked to produce a list with only mutually exclusive intervals</li><li>If you hear the term \u201Coverlapping intervals\u201D.</li></ul><p>Problem patterns:</p><ul><li>Intervals Intersection (medium)</li><li>Maximum CPU Load (hard)</li></ul><ol start="5"><li>Cyclic sort</li></ol><p>pattern iterates over the array one number at a time, and if the current number you are iterating is not at the correct index, you swap it with the number at its correct index.</p><p>How do I identify this pattern?</p><ul><li>They will be problems involving a sorted array with numbers in a given range</li><li>If the problem asks you to find the missing/duplicate/smallest number in an sorted/rotated array</li></ul><p>Problems featuring cyclic sort pattern:</p><ul><li>Find the Missing Number (easy)</li><li>Find the Smallest Missing Positive Number (medium)</li></ul><ol start="6"><li>In-place reversal of linked list</li></ol><p>This pattern reverses one node at a time starting with one variable (current) pointing to the head of the linked list, and one variable (previous) will point to the previous node that you have processed. In a lock-step manner, you will reverse the current node by pointing it to the previous before moving on to the next node. Also, you will update the variable \u201Cprevious\u201D to always point to the previous node that you have processed.</p><p>How do I identify when to use this pattern:</p><ul><li>If you\u2019re asked to reverse a linked list without using extra memory</li></ul><p>Problems featuring in-place reversal of linked list pattern:</p><ul><li>Reverse a Sub-list (medium)</li><li>Reverse every K-element Sub-list (medium)</li></ul><ol start="7"><li>Tree BFS</li></ol><p>This pattern is based on the Breadth First Search (BFS) technique to traverse a tree and uses a queue to keep track of all the nodes of a level before jumping onto the next level.</p><p>works by pushing the root node to the queue and then continually iterating until the queue is empty. For each iteration, we remove the node at the head of the queue and \u201Cvisit\u201D that node. After removing each node from the queue, we also insert all of its children into the queue.</p><p>How to identify the Tree BFS pattern:</p><ul><li>If you\u2019re asked to traverse a tree in a level-by-level fashion (or level order traversal)</li></ul><p>Problems featuring Tree BFS pattern:</p><ul><li>Binary Tree Level Order Traversal (easy)</li><li>Zigzag Traversal (medium)</li></ul><ol start="8"><li>Tree DFS</li></ol><p>You can use recursion (or a stack for the iterative approach) to keep track of all the previous (parent) nodes while traversing.</p><p>The Tree DFS pattern works by starting at the root of the tree, if the node is not a leaf you need to do three things:</p><ol><li>Decide whether to process the current node now (pre-order), or between processing two children (in-order) or after processing both children (post-order).</li><li>Make two recursive calls for both the children of the current node to process them.</li></ol><p>How to identify the Tree DFS pattern:</p><ul><li>If you\u2019re asked to traverse a tree with in-order, preorder, or postorder DFS</li><li>If the problem requires searching for something where the node is closer to a leaf</li></ul><p>Problems featuring Tree DFS pattern:</p><ul><li>Sum of Path Numbers (medium)</li><li>All Paths for a Sum (medium)</li></ul><ol start="9"><li>Two heaps</li></ol>',56);function m(f,v){const i=o("ExternalLinkIcon");return a(),l("div",null,[u,e("p",null,[e("a",p,[d,n(i)])]),c])}const y=r(h,[["render",m],["__file","patterns.html.vue"]]);export{y as default};
